<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Journal Entry - My Journal</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
        }
    </script>
    <style>
        .recording {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        
        /* Touch target improvements */
        .touch-target {
            min-height: 44px;
            min-width: 44px;
        }
        
        /* Mobile-specific styles */
        @media (max-width: 640px) {
            .mobile-stack {
                flex-direction: column;
                align-items: stretch;
            }
            
            .mobile-stack > * {
                margin-bottom: 0.75rem;
            }
            
            .mobile-stack > *:last-child {
                margin-bottom: 0;
            }
        }
    </style>
</head>
<body class="bg-gray-50 dark:bg-gray-900 min-h-screen transition-colors">
    <div class="container mx-auto px-3 sm:px-4 py-4 sm:py-8 max-w-4xl">
        <!-- Header -->
        <div class="flex flex-col sm:flex-row sm:items-center justify-between mb-6 sm:mb-8 space-y-4 sm:space-y-0">
            <button id="backBtn" class="touch-target flex items-center justify-center sm:justify-start text-gray-600 dark:text-gray-400 hover:text-gray-800 dark:hover:text-gray-200 transition-colors bg-white/50 dark:bg-gray-800/50 rounded-xl px-4 py-2 sm:bg-transparent">
                <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                </svg>
                Back to Home
            </button>
            <div class="text-center">
                <h1 class="text-2xl sm:text-3xl font-light text-gray-800 dark:text-gray-100">Journal Entry</h1>
                <p class="text-gray-600 dark:text-gray-400 text-sm" id="entryDate"></p>
            </div>
            <div class="hidden sm:block w-32"></div>
        </div>

        <!-- Mood Display (if available) -->
        <div id="moodDisplay" class="bg-white dark:bg-gray-800 rounded-xl sm:rounded-lg shadow-sm p-3 sm:p-4 mb-4 sm:mb-6 hidden">
            <div class="flex items-center justify-center space-x-3">
                <span class="text-sm text-gray-600 dark:text-gray-400">Today's mood:</span>
                <span id="todayMoodEmoji" class="text-xl sm:text-2xl"></span>
                <span id="todayMoodText" class="text-sm font-medium text-gray-800 dark:text-gray-200"></span>
            </div>
        </div>

        <!-- Journal Entry Form -->
        <div class="bg-white dark:bg-gray-800 rounded-xl sm:rounded-lg shadow-sm p-4 sm:p-6">
            <form id="entryForm" class="space-y-4 sm:space-y-6">
                <!-- Summary Input -->
                <div>
                    <label for="entrySummary" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        One-line summary <span class="text-gray-500">(Optional)</span>
                    </label>
                    <input 
                        type="text" 
                        id="entrySummary" 
                        placeholder="What happened today in one sentence..."
                        class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-gray-100 dark:placeholder-gray-400 text-base"
                    >
                </div>

                <!-- Main Content Area -->
                <div>
                    <label for="entryContent" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                        Your thoughts and reflections
                    </label>
                    <textarea 
                        id="entryContent" 
                        rows="12"
                        placeholder="Start writing your journal entry here..."
                        class="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-xl focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 resize-none dark:bg-gray-700 dark:text-gray-100 dark:placeholder-gray-400 text-base"
                        required
                    ></textarea>
                </div>

                <!-- ðŸ’¬ Talk to me Section -->
                <div class="border-t border-gray-200 dark:border-gray-600 pt-4 sm:pt-6">
                    <h3 class="text-lg font-medium text-gray-800 dark:text-gray-100 mb-4 flex flex-col sm:flex-row sm:items-center">
                        <span class="flex items-center">
                            ðŸ’¬ Talk to me
                        </span>
                        <span class="text-sm text-gray-500 dark:text-gray-400 font-normal mt-1 sm:mt-0 sm:ml-2">Voice Assistant (Auto-detects language)</span>
                    </h3>

                    <!-- Voice Recording Controls -->
                    <div class="mobile-stack flex items-center space-x-4 mb-4">
                        <button type="button" id="recordBtn" class="touch-target px-4 sm:px-6 py-3 bg-red-600 dark:bg-red-700 text-white rounded-xl hover:bg-red-700 dark:hover:bg-red-600 transition-colors font-medium flex items-center justify-center space-x-2 flex-1 sm:flex-initial">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                            </svg>
                            <span id="recordBtnText">Start Recording</span>
                        </button>
                        
                        <div id="recordingStatus" class="text-sm text-gray-600 dark:text-gray-400 hidden">
                            <div class="flex items-center space-x-2">
                                <div class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></div>
                                <span>Recording... <span id="recordingTime">0:00</span></span>
                            </div>
                        </div>
                        
                        <div id="processingStatus" class="text-sm text-blue-600 dark:text-blue-400 hidden">
                            <div class="flex items-center space-x-2">
                                <div class="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600 dark:border-blue-400"></div>
                                <span>Processing with AI...</span>
                            </div>
                        </div>
                    </div>

                    <!-- Voice Instructions -->
                    <div class="bg-blue-50 dark:bg-blue-900 border border-blue-200 dark:border-blue-700 rounded-xl p-4">
                        <h4 class="font-medium text-blue-800 dark:text-blue-200 mb-2">How it works:</h4>
                        <ul class="text-sm text-blue-700 dark:text-blue-300 space-y-1">
                            <li>â€¢ Speak naturally in any language - AI will automatically detect it</li>
                            <li>â€¢ Your speech will be transcribed exactly as spoken</li>
                            <li>â€¢ Translations provided if speaking in non-English languages</li>
                            <li>â€¢ Sentiment is tracked for personalized future journal prompts</li>
                            <li>â€¢ No extra formatting - just your authentic voice in text</li>
                        </ul>
                    </div>
                </div>

                <!-- Action Buttons -->
                <div class="flex flex-col sm:flex-row space-y-3 sm:space-y-0 sm:space-x-4">
                    <button 
                        type="submit" 
                        class="touch-target flex-1 bg-blue-600 dark:bg-blue-700 text-white py-3 rounded-xl hover:bg-blue-700 dark:hover:bg-blue-600 transition-colors font-medium"
                    >
                        Save Entry
                    </button>
                    <button 
                        type="button" 
                        id="deleteBtn" 
                        class="touch-target px-6 py-3 bg-red-600 dark:bg-red-700 text-white rounded-xl hover:bg-red-700 dark:hover:bg-red-600 transition-colors font-medium hidden"
                    >
                        Delete
                    </button>
                </div>
            </form>
        </div>

        <!-- Writing Tips -->
        <div class="mt-4 sm:mt-6 bg-white dark:bg-gray-800 rounded-xl sm:rounded-lg shadow-sm p-4 sm:p-6">
            <h3 class="text-lg font-medium text-gray-800 dark:text-gray-100 mb-3">Writing Tips</h3>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 text-sm text-gray-600 dark:text-gray-400">
                <div>
                    <h4 class="font-medium text-gray-800 dark:text-gray-200 mb-1">Reflect on your day</h4>
                    <p>What went well? What challenges did you face?</p>
                </div>
                <div>
                    <h4 class="font-medium text-gray-800 dark:text-gray-200 mb-1">Express your emotions</h4>
                    <p>How are you feeling? What emotions came up?</p>
                </div>
                <div>
                    <h4 class="font-medium text-gray-800 dark:text-gray-200 mb-1">Use voice assistant</h4>
                    <p>Speak naturally in your preferred language for easy journaling</p>
                </div>
                <div>
                    <h4 class="font-medium text-gray-800 dark:text-gray-200 mb-1">Be honest</h4>
                    <p>This is your safe space - write authentically</p>
                </div>
            </div>
        </div>
        
        <!-- Mobile Bottom Padding -->
        <div class="h-4 sm:h-0"></div>
    </div>

    <script>
        class JournalEntry {
            constructor() {
                this.currentDate = this.getDateFromURL() || new Date().toISOString().split('T')[0];
                this.entries = this.loadEntries();
                this.moods = this.loadMoods();
                this.sentiments = this.loadSentiments();
                this.moodLabels = ['Sad', 'Frustrated', 'Confused', 'Anxious', 'Neutral', 'Happy', 'Content', 'Excited'];
                this.moodEmojis = ['ðŸ˜­', 'ðŸ˜¡', 'ðŸ«¤', 'ðŸ˜¨', 'ðŸ˜', 'ðŸ˜„', 'ðŸ˜Œ', 'ðŸ¤©'];
                this.autoSaveTimer = null;
                this.isRecording = false;
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.recordingTimer = null;
                this.recordingStartTime = null;
                // WARNING: In production, use environment variables or backend API
                this.GEMINI_API_KEY = 'AIzaSyC_ZRimxlh9GdFO5RdfKh0CBkC57Esr5NI';
                this.init();
            }

            init() {
                // Initialize dark mode
                this.initDarkMode();
                
                this.setupDateDisplay();
                this.loadExistingEntry();
                this.displayMood();
                this.showPreviousSentiment();
                this.bindEvents();
                this.setupVoiceRecording();
                this.setupMobileOptimizations();
                document.getElementById('entryContent').focus();
            }

            initDarkMode() {
                const isDarkMode = localStorage.getItem('darkMode') === 'true';
                if (isDarkMode) {
                    document.documentElement.classList.add('dark');
                }
            }

            setupDateDisplay() {
                const date = new Date(this.currentDate);
                const options = { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                };
                document.getElementById('entryDate').textContent = date.toLocaleDateString('en-US', options);
            }

            getDateFromURL() {
                const urlParams = new URLSearchParams(window.location.search);
                return urlParams.get('date');
            }

            loadExistingEntry() {
                const existingEntry = this.entries[this.currentDate];
                if (existingEntry) {
                    const lines = existingEntry.split('\n');
                    const summary = lines[0].startsWith('**Summary:**') ? lines[0].replace('**Summary:** ', '') : '';
                    const content = lines.slice(summary ? 2 : 0).join('\n'); // Skip summary and empty line if present
                    
                    document.getElementById('entrySummary').value = summary;
                    document.getElementById('entryContent').value = content;
                    document.getElementById('deleteBtn').classList.remove('hidden');
                }
            }

            displayMood() {
                const todaysMood = this.moods[this.currentDate];
                if (todaysMood !== undefined) {
                    document.getElementById('moodDisplay').classList.remove('hidden');
                    document.getElementById('todayMoodEmoji').textContent = this.moodEmojis[todaysMood];
                    document.getElementById('todayMoodText').textContent = this.moodLabels[todaysMood];
                }
            }

            showPreviousSentiment() {
                const entryContent = document.getElementById('entryContent');
                const existingEntry = this.entries[this.currentDate];
                
                // Only show previous sentiment if this is a new entry
                if (!existingEntry || existingEntry.trim() === '') {
                    const yesterday = new Date(this.currentDate);
                    yesterday.setDate(yesterday.getDate() - 1);
                    const yesterdayDate = yesterday.toISOString().split('T')[0];
                    
                    const previousSentiment = this.sentiments[yesterdayDate];
                    
                    if (previousSentiment) {
                        const welcomeText = `You were feeling ${previousSentiment.toLowerCase()} last time you were here. How is your day today?\n\n`;
                        entryContent.value = welcomeText;
                        // Position cursor at the end
                        entryContent.setSelectionRange(welcomeText.length, welcomeText.length);
                    }
                }
            }

            bindEvents() {
                document.getElementById('backBtn').addEventListener('click', () => {
                    window.location.href = 'index.html';
                });

                document.getElementById('entryForm').addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.saveEntry();
                });

                document.getElementById('deleteBtn').addEventListener('click', () => {
                    this.deleteEntry();
                });

                // Auto-save draft
                let autoSaveTimeout;
                const autoSave = () => {
                    clearTimeout(autoSaveTimeout);
                    autoSaveTimeout = setTimeout(() => {
                        this.saveDraft();
                    }, 2000);
                };

                document.getElementById('entryContent').addEventListener('input', autoSave);
                document.getElementById('entrySummary').addEventListener('input', autoSave);

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        window.location.href = 'index.html';
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault();
                        this.saveEntry();
                    }
                });
            }

            setupVoiceRecording() {
                const recordBtn = document.getElementById('recordBtn');
                
                recordBtn.addEventListener('click', () => {
                    if (this.isRecording) {
                        this.stopRecording();
                    } else {
                        this.startRecording();
                    }
                });
            }

            setupMobileOptimizations() {
                // Prevent zoom on input focus on iOS
                if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
                    const viewport = document.querySelector('meta[name="viewport"]');
                    if (viewport) {
                        viewport.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no';
                    }
                }

                // Add better touch support for mobile recording
                const recordBtn = document.getElementById('recordBtn');
                recordBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    // Add visual feedback
                    recordBtn.style.transform = 'scale(0.95)';
                });

                recordBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    recordBtn.style.transform = 'scale(1)';
                });

                // Improve scrolling on mobile
                document.querySelectorAll('textarea, select').forEach(element => {
                    element.style.webkitOverflowScrolling = 'touch';
                });

                // Handle mobile keyboard better
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', () => {
                        // Adjust layout when mobile keyboard appears
                        const vh = window.visualViewport.height * 0.01;
                        document.documentElement.style.setProperty('--vh', `${vh}px`);
                    });
                }
            }

            async startRecording() {
                try {
                    // Check for mobile browser compatibility
                    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                        alert('Voice recording is not supported on this device/browser. Please try using Chrome or Safari.');
                        return;
                    }

                    // Request microphone permission with optimized constraints for speech recognition
                    const constraints = {
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true,
                            sampleRate: 16000, // Optimal for speech recognition
                            channelCount: 1,    // Mono audio
                            sampleSize: 16      // 16-bit audio
                        }
                    };

                    const stream = await navigator.mediaDevices.getUserMedia(constraints);
                    
                    // Determine the best audio format for the API
                    let mimeType = 'audio/webm';
                    if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                        mimeType = 'audio/webm;codecs=opus';
                    } else if (MediaRecorder.isTypeSupported('audio/mp4')) {
                        mimeType = 'audio/mp4';
                    } else if (MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
                        mimeType = 'audio/ogg;codecs=opus';
                    } else if (!MediaRecorder.isTypeSupported('audio/webm')) {
                        alert('Audio recording format not supported on this device. Please try a different browser.');
                        stream.getTracks().forEach(track => track.stop());
                        return;
                    }

                    console.log('Using MIME type:', mimeType);
                    
                    this.mediaRecorder = new MediaRecorder(stream, { 
                        mimeType: mimeType,
                        audioBitsPerSecond: 128000 // Good quality for speech
                    });
                    
                    const audioChunks = [];

                    this.mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunks.push(event.data);
                        }
                    };

                    this.mediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(audioChunks, { type: mimeType });
                        console.log('Audio recording complete. Size:', audioBlob.size, 'bytes');
                        
                        if (audioBlob.size === 0) {
                            alert('No audio was recorded. Please try again and make sure you speak clearly.');
                            return;
                        }
                        
                        await this.processAudioWithGemini(audioBlob);
                        
                        // Stop all tracks to release microphone
                        stream.getTracks().forEach(track => track.stop());
                    };

                    this.mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                        alert('Recording error occurred. Please try again.');
                        stream.getTracks().forEach(track => track.stop());
                    };

                    // Start recording with data available every 100ms for better quality
                    this.mediaRecorder.start(100);
                    this.isRecording = true;
                    this.updateRecordingUI();
                    this.startRecordingTimer();

                } catch (error) {
                    console.error('Error starting recording:', error);
                    
                    let errorMessage = 'Could not access microphone. ';
                    if (error.name === 'NotAllowedError') {
                        errorMessage += 'Please allow microphone access in your browser settings and try again.';
                    } else if (error.name === 'NotFoundError') {
                        errorMessage += 'No microphone found on this device.';
                    } else if (error.name === 'NotSupportedError') {
                        errorMessage += 'Voice recording is not supported on this browser. Try Chrome or Safari.';
                    } else if (error.name === 'NotReadableError') {
                        errorMessage += 'Microphone is being used by another application. Please close other apps and try again.';
                    } else {
                        errorMessage += 'Please check your microphone permissions and try again.';
                    }
                    
                    alert(errorMessage);
                }
            }

            stopRecording() {
                if (this.mediaRecorder && this.isRecording) {
                    this.mediaRecorder.stop();
                    this.isRecording = false;
                    this.updateRecordingUI();
                    this.stopRecordingTimer();
                }
            }

            startRecordingTimer() {
                this.recordingStartTime = Date.now();
                this.recordingTimer = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                    const minutes = Math.floor(elapsed / 60);
                    const seconds = elapsed % 60;
                    document.getElementById('recordingTime').textContent = 
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                }, 1000);
            }

            stopRecordingTimer() {
                if (this.recordingTimer) {
                    clearInterval(this.recordingTimer);
                    this.recordingTimer = null;
                }
            }

            updateRecordingUI() {
                const recordBtn = document.getElementById('recordBtn');
                const recordBtnText = document.getElementById('recordBtnText');
                const recordingStatus = document.getElementById('recordingStatus');

                if (this.isRecording) {
                    recordBtn.className = 'touch-target px-4 sm:px-6 py-3 bg-gray-600 dark:bg-gray-700 text-white rounded-xl hover:bg-gray-700 dark:hover:bg-gray-600 transition-colors font-medium flex items-center justify-center space-x-2 flex-1 sm:flex-initial';
                    recordBtnText.textContent = 'Stop Recording';
                    recordingStatus.classList.remove('hidden');
                } else {
                    recordBtn.className = 'touch-target px-4 sm:px-6 py-3 bg-red-600 dark:bg-red-700 text-white rounded-xl hover:bg-red-700 dark:hover:bg-red-600 transition-colors font-medium flex items-center justify-center space-x-2 flex-1 sm:flex-initial';
                    recordBtnText.textContent = 'Start Recording';
                    recordingStatus.classList.add('hidden');
                }
            }

            async processAudioWithGemini(audioBlob) {
                const processingStatus = document.getElementById('processingStatus');
                processingStatus.classList.remove('hidden');

                try {
                    // Convert audio blob to base64
                    const base64Audio = await this.blobToBase64(audioBlob);
                    
                    // Get the correct MIME type for the audio
                    const mimeType = audioBlob.type || 'audio/webm';
                    console.log('Audio blob size:', audioBlob.size, 'MIME type:', mimeType);
                    
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${this.GEMINI_API_KEY}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            contents: [{
                                parts: [
                                    {
                                        text: `You are a voice transcription assistant for a personal journal app. Please:

1. Automatically detect the language being spoken
2. Transcribe the audio accurately in the original language
3. If the language is not English, also provide an English translation
4. Analyze the sentiment/emotion (Happy, Sad, Anxious, Excited, Neutral, Content, Frustrated, Confused, etc.)

Please format your response as:
TRANSCRIPTION: [exact transcription in original language]
TRANSLATION: [English translation if needed, otherwise write "N/A"]
SENTIMENT: [one word emotion]

Keep the transcription natural and exactly as spoken. Do not add extra formatting or editorial content.`
                                    },
                                    {
                                        inline_data: {
                                            mime_type: mimeType,
                                            data: base64Audio.split(',')[1]
                                        }
                                    }
                                ]
                            }],
                            generationConfig: {
                                temperature: 0.3,
                                maxOutputTokens: 500,
                            }
                        })
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        throw new Error(`API Error ${response.status}: ${errorText}`);
                    }

                    const data = await response.json();
                    
                    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
                        throw new Error('Invalid response from API - no content generated');
                    }
                    
                    const aiResponse = data.candidates[0].content.parts[0].text;
                    console.log('AI Response:', aiResponse);
                    
                    // Parse the response
                    const transcriptionMatch = aiResponse.match(/TRANSCRIPTION:\s*(.+?)(?:\n|TRANSLATION:)/s);
                    const translationMatch = aiResponse.match(/TRANSLATION:\s*(.+?)(?:\n|SENTIMENT:)/s);
                    const sentimentMatch = aiResponse.match(/SENTIMENT:\s*(.+?)(?:\n|$)/s);
                    
                    const transcription = transcriptionMatch ? transcriptionMatch[1].trim() : 'Could not transcribe audio';
                    const translation = translationMatch ? translationMatch[1].trim() : '';
                    const sentiment = sentimentMatch ? sentimentMatch[1].trim() : 'Neutral';
                    
                    // Store sentiment for next journal entry
                    this.saveSentiment(sentiment);
                    
                    // Add transcription to journal entry
                    let finalText = transcription;
                    if (translation && translation !== 'N/A' && translation.toLowerCase() !== transcription.toLowerCase()) {
                        finalText += `\n\n[Translation: ${translation}]`;
                    }
                    
                    this.addVoiceContentToEntry(finalText);

                } catch (error) {
                    console.error('Error processing audio with Gemini:', error);
                    
                    let userMessage = 'Error processing audio. ';
                    
                    if (error.message.includes('API Error 400')) {
                        userMessage += 'The audio format may not be supported. Please try recording again.';
                    } else if (error.message.includes('API Error 401') || error.message.includes('API Error 403')) {
                        userMessage += 'Authentication error. Please contact support.';
                    } else if (error.message.includes('API Error 429')) {
                        userMessage += 'Too many requests. Please wait a moment and try again.';
                    } else if (error.message.includes('Invalid response')) {
                        userMessage += 'The AI could not process your audio. Please try speaking more clearly.';
                    } else if (error.name === 'TypeError' && error.message.includes('fetch')) {
                        userMessage += 'Network error. Please check your internet connection.';
                    } else {
                        userMessage += 'Please try again or check your microphone.';
                    }
                    
                    alert(userMessage);
                } finally {
                    processingStatus.classList.add('hidden');
                }
            }

            saveSentiment(sentiment) {
                const sentiments = this.loadSentiments();
                sentiments[this.currentDate] = sentiment;
                localStorage.setItem('journalSentiments', JSON.stringify(sentiments));
            }

            loadSentiments() {
                const stored = localStorage.getItem('journalSentiments');
                return stored ? JSON.parse(stored) : {};
            }

            addVoiceContentToEntry(aiResponse) {
                const entryContent = document.getElementById('entryContent');
                const currentContent = entryContent.value;
                
                // Add separator if there's existing content
                const separator = currentContent.trim() ? '\n\n---\n\n' : '';
                const newContent = currentContent + separator + aiResponse + '\n\n';
                
                entryContent.value = newContent;
                
                // Auto-focus at the end
                entryContent.focus();
                entryContent.setSelectionRange(entryContent.value.length, entryContent.value.length);
                
                // Trigger auto-save
                entryContent.dispatchEvent(new Event('input'));
            }

            blobToBase64(blob) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                });
            }

            saveEntry() {
                const summary = document.getElementById('entrySummary').value.trim();
                const content = document.getElementById('entryContent').value.trim();

                if (!content) {
                    alert('Please write something in your journal entry.');
                    return;
                }

                let finalEntry = '';
                if (summary) {
                    finalEntry = `**Summary:** ${summary}\n\n${content}`;
                } else {
                    finalEntry = content;
                }

                this.entries[this.currentDate] = finalEntry;
                this.saveEntries();

                // Remove any draft
                this.removeDraft();

                // Show success message and redirect
                alert('Journal entry saved successfully!');
                window.location.href = 'index.html';
            }

            saveDraft() {
                const summary = document.getElementById('entrySummary').value.trim();
                const content = document.getElementById('entryContent').value.trim();

                if (content || summary) {
                    const draft = { summary, content, date: this.currentDate };
                    localStorage.setItem('journalDraft', JSON.stringify(draft));
                }
            }

            removeDraft() {
                localStorage.removeItem('journalDraft');
            }

            deleteEntry() {
                if (confirm('Are you sure you want to delete this journal entry? This action cannot be undone.')) {
                    delete this.entries[this.currentDate];
                    this.saveEntries();
                    this.removeDraft();
                    window.location.href = 'index.html';
                }
            }

            loadEntries() {
                const stored = localStorage.getItem('journalEntries');
                return stored ? JSON.parse(stored) : {};
            }

            loadMoods() {
                const stored = localStorage.getItem('journalMoods');
                return stored ? JSON.parse(stored) : {};
            }

            saveEntries() {
                localStorage.setItem('journalEntries', JSON.stringify(this.entries));
            }
        }

        const journalEntry = new JournalEntry();
    </script>
</body>
</html> 